{"ast":null,"code":"import { HttpParams } from \"@angular/common/http\";\nimport { map } from \"rxjs/operators\";\nimport { WeatherConditionsConstants } from \"../../shared/constants/weather-conditions.constants\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"../../shared/service/shared.service\";\nexport let ForecastWeatherService = /*#__PURE__*/(() => {\n  class ForecastWeatherService {\n    constructor(http, datePipe, sharedService) {\n      this.http = http;\n      this.datePipe = datePipe;\n      this.sharedService = sharedService;\n    }\n\n    getForecastWeather(zipCode) {\n      let httpParams = new HttpParams();\n      httpParams = httpParams.append(WeatherConditionsConstants.ZIP_HTTP_PARAM, zipCode);\n      httpParams = httpParams.append(WeatherConditionsConstants.CNT_HTTP_PARAM, '5');\n      return this.http.get('http://api.openweathermap.org/data/2.5/forecast/daily', {\n        params: httpParams\n      }).pipe(map(response => {\n        return this.convertResponseToForecastWeatherModel(response, zipCode);\n      }));\n    }\n\n    convertResponseToForecastWeatherModel(forecastWeatherResponse, zipCode) {\n      let forecastWeather = Object.assign({\n        zipCode: zipCode,\n        locationName: '',\n        conditions: []\n      });\n      let missingFields = [];\n\n      if (!forecastWeatherResponse.city || !forecastWeatherResponse.city.name) {\n        missingFields.push('location name');\n      } else {\n        forecastWeather.locationName = forecastWeatherResponse.city.name;\n      }\n\n      if (!forecastWeatherResponse.list) {\n        missingFields.push('list of conditions');\n      } else {\n        const temperatures = forecastWeatherResponse.list;\n        let index = 0;\n\n        for (let temperature of temperatures) {\n          let condition = {};\n\n          if (!temperature.weather || !temperature.weather[0] || !temperature.weather[0].main) {\n            missingFields.push('weather condition of index ' + index);\n          } else {\n            const weatherConditions = temperature.weather[0].main === 'Clear' ? 'Sunny' : temperature.weather[0].main;\n            condition.weatherConditions = weatherConditions;\n            condition.icon = WeatherConditionsConstants.WEATHER_ICON.hasOwnProperty(weatherConditions) ? WeatherConditionsConstants.WEATHER_ICON[weatherConditions] : WeatherConditionsConstants.WEATHER_ICON.NoIcon;\n          }\n\n          if (!temperature.dt) {\n            missingFields.push('weather date of index ' + index);\n          } else {\n            condition.weatherDate = this.datePipe.transform(temperature.dt * 1000, 'EEEE, LLL dd');\n          }\n\n          if (!temperature.temp || !temperature.temp.min) {\n            missingFields.push('min temperature of index ' + index);\n          } else {\n            condition.minTemperature = temperature.temp.min;\n          }\n\n          if (!temperature.temp || !temperature.temp.max) {\n            missingFields.push('max temperature of index ' + index);\n          } else {\n            condition.maxTemperature = temperature.temp.max;\n          }\n\n          forecastWeather.conditions.push(condition);\n          index++;\n        }\n      }\n\n      this.sharedService.sendErrorMessage(missingFields);\n      return forecastWeather;\n    }\n\n  }\n\n  ForecastWeatherService.ɵfac = function ForecastWeatherService_Factory(t) {\n    return new (t || ForecastWeatherService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.DatePipe), i0.ɵɵinject(i3.SharedService));\n  };\n\n  ForecastWeatherService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ForecastWeatherService,\n    factory: ForecastWeatherService.ɵfac,\n    providedIn: 'root'\n  });\n  return ForecastWeatherService;\n})();","map":null,"metadata":{},"sourceType":"module"}